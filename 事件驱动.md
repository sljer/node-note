### 一、Node.js简介
#### 1.1 简介 
官网：https://nodejs.org/en/
特点：Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient.

**V8引擎：**V8引擎本身就是用于Chrome浏览器的JS解释部分，但是Ryan Dahl把这个V8引擎搬到了服务器上用于做服务器的软件。

**Node.js是一个让JavaScript运行在服务器端的开发平台**，它让JavaScript的触♂手伸到了服务器端，但Node似乎有点不同：
<!--more-->
● Node.js不是一种独立的语言，与PHP、JSP、Python、Perl、Ruby的“既是语言，也是平台”不同，Node.js的使用JavaScript进行编程，运行在JavaScript引擎上（V8）;

● 与PHP、JSP等相比（PHP、JSP、.net都需要运行在服务器程序上，Apache、Naginx、Tomcat、IIS…），Node.js跳过了Apache、Naginx、IIS等HTTP服务器，它自己不用建设在任何服务器软件之上。

Node.js的许多设计理念与经典架构（LAMP = Linux + Apache + MySQL + PHP）有着很大的不同，可以提供强大的伸缩能力。因为Node.js没有web容器。

Node.js的哲♂学：花最小的硬件成本，追求更高的并发，更高的处理性能。

#### 1.2 特点
所谓的特点，就是Node.js是如何解决服务器高性能瓶颈问题的。

**单线程**
在Java、PHP或者.net等服务器端语言中，会为每一个客户端连接创建一个新的线程。而每个线程需要耗费大约2MB内存。也就是说，理论上，一个8GB内存的服务器可以同时连接的最大用户数为4000个左右。要让Web应用程序支持更多的用户，就需要增加服务器的数量，而Web应用程序的硬件成本当然就上升了。

    Node.js不为每个客户连接创建一个新的线程，而仅仅使用一个线程。当有用户连接了，就触发一个内部事件，通过非阻塞I/O、事件驱动机制，让Node.js程序宏观上也是并行的。使用Node.js，一个8GB内存的服务器，可以同时处理超过4万用户的连接。


**单线程的好处：**操作系统完全不再有线程创建、销毁的时间开销。
**单线程的坏处：**一个用户造成了线程的崩溃，整个服务都崩溃了，其他人也崩溃了。

<单线程也能造成宏观上的“并发”>

------------

**非阻塞I/O non-blocking I/O**

当在访问数据库取得数据的时候，需要一段时间。在传统的单线程处理机制中，在执行了访问数据库代码之后，整个线程都将暂停下来，等待数据库返回结果，才能执行后面的代码。

也就是说，I/O阻塞了代码的执行，极大地降低了程序的执行效率。

由于**Node.js中采用了非阻塞型I/O机制，因此在执行了访问数据库的代码之后，将立即转而执行其后面的代码，把数据库返回结果的处理代码放在回调函数中**，从而提高了程序的执行效率。

	当某个I/O执行完毕时，将以事件的形式通知执行I/O操作的线程，线程执行这个事件的回调函数。为了处理异步I/O，线程必须有事件循环，不断的检查有没有未处理的事件，依次予以处理。

阻塞模式下，一个线程只能处理一项任务，要想提高吞吐量必须通过多线程。

而非阻塞模式下，一个线程永远在执行计算操作，这个线程的CPU核心利用率永远是100%。所以，这是一种特别有哲♂理的解决方案：与其人多一♂起♂干，但是好多人闲着，还不如一个人往♂死♂里♂干。

------------

**事件驱动event-driven**

在Node中，客户端请求建立连接，提交数据等行为，会触发相应的事件，**在一个时刻，只能执行一个事件回调函数，但是在执行一个事件回调函数的中途，可以转而处理其他事件（比如，又有新用户连接了），然后返回继续执行原事件的回调函数，这种处理机制，称为“事件环”机制。**
<!--[![](http://blog.wuyuejianjue.com/usr/themes/next/images/a3.png)](http://wuyuejianjue/blog/wuyuejianjue/usr/themes/next/images/a3.png)-->
------------

Node.js底层是C++（V8也是C++写的）。底层代码中，近半数都用于事件队列、回调函数队列的构建。

**用事件驱动来完成服务器的任务调度，用一个线程，担负起了处理非常多的任务的使命。**

单线程，单线程的好处，减少了内存开销，操作系统的内存换页。

如果某一个事情，进入了，但是被I/O阻塞了，所以这个线程就阻塞了。

**非阻塞I/O，不会死等I/O语句结束，而会执行后面的语句。**

非阻塞就能解决问题了么？比如执行着小红的业务，执行过程中，小刚的I/O回调完成了，此时怎么办？？

**事件机制，事件环，不管是新用户的请求，还是老用户的I/O完成，都将以事件方式加入事件环，等待调度。**

说是三个特点，实际上是一个特点，离开谁都不行。

Node.js很像抠门的餐厅老板，只聘请1个服务员，服务很多人。结果，比很多服务员效率还高。

Node.js中所有的I/O都是异步的，回调函数，套回调函数。

------------

**Node.js适合开发什么？**

Node.js适合用来开发什么样的应用程序呢？
善于I/O，不善于计算。因为Node.js最擅长的就是任务调度，如果你的业务有很多的CPU计算，实际上也相当于这个计算阻塞了这个单线程，就不适合Node开发。

	当应用程序需要处理大量并发的I/O，而在向客户端发出响应之前，应用程序内部并不需要进行非常复杂的处理的时候，Node.js非常适合。Node.js也非常适合与websocket配合，开发长连接的实时交互应用程序。

比如：
● 用户表单收集
● 考试系统
● 聊天室
● 图文直播
● 提供JSON的API（为前台Angular使用）

------------
Node无法挑战PHP、JSP等老牌后台语言

Node.js本是就是极客追求性能极致的产物，缺少了很多服务器的健壮考量。所以Node不可能应用在银行、证券、电信等需要极高可靠性的业务中。

中国的企业实战中，创业型公司（正处于A轮、B轮）非常爱使用Node做核心业务：
■ 功夫熊的APP，后台是Node.js在伺服
■ 实现网，整站为Node.js搭建
成熟大企业，基本上都是用Node实现某一方面的功能：
■ 知乎用了一个Node进程，跑起了“站内信”功能
■ 百度的很多表单，是用Node保存到数据库的

Node不是银弹，就是你工具箱中的一个小工具而已。

------------

Node.js是服务器的程序，写的js语句，都将运行在服务器上。返回给客户的，都是已经处理好的纯html。
```javascript
//require表示引包，引包就是引用自己的一个特殊功能
var http = require("http");
//创建服务器，参数是一个回调函数，表示如果有请求进来，要做什么
var server = http.createServer(function(req,res){
	//req表示请求，request;  res表示响应，response
	//设置HTTP头部，状态码是200，文件类型是html，字符集是utf8
	res.writeHead(200,{"Content-type":"text/html;charset=UTF-8"});
	res.end("哈哈哈哈，我买了五个iPhone" + (1+2+3) + "s");
});

//运行服务器，监听3000端口（端口号可以任改）
server.listen(3000,"127.0.0.1");
```
如果想修改程序，必须中断当前运行的服务器，重新node一次，刷新，才行。

ctrl+c，就可以打断挂起的服务器程序。此时按上箭头，能够快速调用最近的node命令。

你会发现，我们本地写一个js，打死都不能直接拖入浏览器运行，但是有了node，我们任何一个js文件，都可以通过node来运行。也就是说，**node就是一个js的执行环境**。

我们现在，要跑起来一个服务器，这个服务器的脚本，要以.js存储。是一个js文件。用node命令运行这个js文件罢了。

------------

**Node.js没有根目录的概念，因为它根本没有任何的web容器！**

让node.js提供一个静态服务，都非常难！
也就是说，node.js中，如果看见一个网址是
1	127.0.0.1:3000/fang
别再去想，一定有一个文件夹，叫做fang了。可能/fang的物理文件，是同目录的test.html

**URL和真实物理文件，是没有关系的。URL是通过了Node的顶层路由设计，呈递某一个静态文件的。**

------------

#### 1.3 http模块
Node.js中，将很多的功能，划分为了一个个mudule，大陆的书翻译为模块；台湾的书，翻译为模组。

这是因为，有一些程序需要使用fs功能（文件读取功能），有一些不用的，所以为了效率，你用啥，你就require啥。
```javascript
//简单讲解http模块
//引用模块
	var http = require("http");
//创建一个服务器，回调函数表示接收到请求之后做的事情
	var server = http.createServer(function(req,res){
//req参数表示请求，res表示响应
		console.log("服务器接收到了请求" + req.url);
		res.end();
	});
//监听端口
	server.listen(3000,"127.0.0.1");
```
我们现在来看一下req里面能够使用的东西。
最关键的就是req.url属性，表示用户的请求URL地址。所有的路由设计，都是通过req.url来实现的。

我们比较关心的不是拿到URL，而是识别这个URL。
识别URL，用到两个新模块，第一个就是url模块，第二个就是querystring模块

字符串查询，用querystring处理
```javascript
querystring.parse('foo=bar&baz=qux&baz=quux&corge')
// returns
	{ foo: 'bar', baz: ['qux', 'quux'], corge: '' }
	
// Suppose gbkDecodeURIComponent function already exists,
// it can decode `gbk` encoding string
	querystring.parse('w=%D6%D0%CE%C4&foo=bar', null, null,
	{
	  decodeURIComponent:
				gbkDecodeURIComponent
		})
// returns
	{ w: '中文', foo: 'bar' }
```

------------

总结：

Node.js开发服务器，数据、路由。本地关心的效果，交互；

Node.js实际上是极客开发出的一个小玩具，不是银弹。有着别人不具备的怪异特点：单线程、Non-blocking I/O、Event Driven。 实际上是一个特点。

首先，Node不为每个用户开辟一个线程，所以非常极端的选择了单线程。单线程，要照顾所有的用户，那么就必须有非阻塞I/O，否则一个人的I/O就把别人、自己都阻塞了。

	一旦有非阻塞I/O，一个人如果I/O去了，就会放弃CPU的使用权，换成另一个人使用CPU（或者执行此人后面的语句）。所以CPU的利用率100%。第一个人I/O结束了，就要用事件来通知线程，执行回调函数。此时必须有事件环，就有一个排队调度机制。Node中有超过半数的C++代码，在搭建事件环。

Node.js和别的老牌3P不一样： 

1） 没有自己的语法，使用V8引擎，所以就是JS。V8引擎解析JS的，效率非常高，并且V8中很多东西都是异步的。Node就是将V8中的一些功能自己没有重写（别人做了，自己就站在巨人肩膀上），移植到了服务器上。

2） 没有web容器，就是安装配置完成之后，没有一个根目录。

命令提示符所在路径太重要了，因为程序中的所有相对路径”./”，都是相对这个命令提示符路径的，而不是相对于js文件自己。
系统中，80端口，就是默认http端口。所以当没有端口号的时候，就是80端口。

`server.listen(80,"127.0.0.1");`













